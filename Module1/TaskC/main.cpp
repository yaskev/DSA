#include <iostream>#include <vector>#include <iterator>#include <queue>#include <memory>#include <unordered_set>#include <array>#include <map>#pragma GCC optimize("Ofast,unroll-all-loops")class Trie {public:    explicit Trie (const std::map<size_t, std::string>&);    size_t getPieceNumber() { return pieceNumber; }    size_t getPatternSize() { return patternSize; }    void makeMove(char c) { currentVertex = getLink(currentVertex, c); }    std::vector<int32_t> getStringsEndingHere();    std::vector<int32_t> getSubstringsEndingHere();private:    struct Node;    std::unique_ptr<Node> root;    void makeAllLinks();    Node *currentVertex = root.get();    Node *getSufLink (Node*);    Node *getLink (Node*, char c);    Node *getCompressedSufLink (Node*);    size_t patternSize = 0;    size_t pieceNumber = 0;    static constexpr size_t alphabetSize = 26;    static constexpr char base = 'a';};struct Trie::Node {    std::array<std::unique_ptr<Node>, alphabetSize> children;    std::array<Node*, alphabetSize> link{};    std::unordered_set<int32_t> terminalForIndex;    Node *parent = nullptr;    Node *sufLink = nullptr;    Node *compressedSuffLink = nullptr;    char sonByChar = 0;    size_t depth = 0; // Only for terminal vertices    Node(){        for (int i = 0; i < alphabetSize; ++i) {            link[i] = nullptr;        }    }};std::vector<int32_t> Trie::getSubstringsEndingHere() {    std::vector<int32_t> res(currentVertex->terminalForIndex.size());    for (const int32_t elem : currentVertex->terminalForIndex) {        res.push_back(elem + currentVertex->depth);    }    return res;}std::vector<int32_t> Trie::getStringsEndingHere() {    std::vector<int32_t> res;    Node *tmp = currentVertex->compressedSuffLink;    while (tmp != root.get()) {        for (const int32_t elem : tmp->terminalForIndex) {            res.push_back(elem + tmp->depth);        }        tmp = tmp->compressedSuffLink;    }    return res;}Trie::Trie( const std::map<size_t, std::string>& parts ) {    patternSize = parts.crbegin()->first + parts.crbegin()->second.size();    root = std::make_unique<Node>();    currentVertex = root.get();    for( auto const& [start, substr]: parts ) {        Node *current = root.get();        for( char c : substr ) {            if( !current->children[c - base] ) {                auto newChild = std::make_unique<Node>();                newChild->parent = current;                newChild->sonByChar = c;                current->children[c - base] = std::move(newChild);            }            current = current->children[c - base].get();        }        current->terminalForIndex.insert(start);        current->depth = static_cast<size_t>(substr.size());    }    makeAllLinks();    pieceNumber = parts.size();};void Trie::makeAllLinks() {    // Will write bfs    root->sufLink = root.get();    root->compressedSuffLink = root.get();    std::queue<Node*> queue;    queue.push(root.get());    while( !queue.empty() ) {        Node* curr = queue.front();        queue.pop();        curr->sufLink = getSufLink(curr);        curr->compressedSuffLink = getCompressedSufLink(curr);        for( const auto& it : curr->children ) {            if( it ) {                queue.push( it.get() );            }        }    }}std::map<size_t, std::string> split( const std::string& str, char delim='?' ) {    std::map<size_t, std::string> res;    std::string part;    size_t startIndex = 0;    for( size_t i = 0; i < str.size(); ++i ) {        if( str[i] != delim ) {            if( part.empty() ) {                startIndex = i;            }            part += str[i];        } else if( !part.empty() ) {            res[startIndex] = part;            part = "";        }    }    if( !part.empty() ) {        res[startIndex] = part;    }    return res;}Trie::Node* Trie::getLink( Node* node, char c ) {    if( !node->link[c - base] ) {        if( node->children[c - base] ) {            node->link[c - base] = node->children[c - base].get();        } else if( node == root.get() ) {            node->link[c - base] = root.get();        } else {            node->link[c - base] = getLink(getSufLink(node), c);        }    }    return node->link[c - base];}Trie::Node* Trie::getSufLink( Node* node ) {    if( node->sufLink == nullptr ) {        if( node == root.get() || node->parent == root.get() ) {            node->sufLink = root.get();        } else {            node->sufLink = getLink( getSufLink(node->parent), node->sonByChar );        }    }    return node->sufLink;}inline Trie::Node* Trie::getCompressedSufLink( Node* node ) {    if( node->compressedSuffLink == nullptr ) {        if( !getSufLink(node)->terminalForIndex.empty() ) {            node->compressedSuffLink = getSufLink(node);        } else if( getSufLink(node) == root.get() ) {            node->compressedSuffLink = root.get();        } else {            node->compressedSuffLink = getCompressedSufLink(getSufLink(node));        }    }    return node->compressedSuffLink;}template <typename BeginIterator, typename EndIterator>void printMatches(BeginIterator in, EndIterator eof, Trie& trie) {    size_t patternSize = trie.getPatternSize();    size_t pieceNumber = trie.getPieceNumber();    std::vector<size_t> matches( 2 * patternSize, 0 );    size_t charNum = 0;    while( in != eof ) {        if( matches[(charNum + patternSize) % (2 * patternSize)] == pieceNumber ) {            std::cout << charNum - patternSize << " ";        }        matches[(charNum + patternSize) % (2 * patternSize)] = 0;        trie.makeMove(*in);        for (size_t index : trie.getStringsEndingHere()) {            if (charNum > patternSize || charNum + 1 >= index) {                matches[(charNum + 1 - index) % (2 * patternSize)] += 1;            }        }//        curr = trie.getLink(curr, *in);//        if( !curr->terminalForIndex.empty() ) {//            for( const int32_t index : curr->terminalForIndex ) {//                if( charNum > patternSize || charNum + 1 >= index + curr->depth ) {//                    matches[(charNum + 1 - (index + curr->depth)) % (2 * patternSize)] += 1;//                }//            }//        }        for (size_t index : trie.getSubstringsEndingHere()) {            if (charNum > patternSize || charNum + 1 >= index) {                matches[(charNum + 1 - index) % (2 * patternSize)] += 1;            }        }//        Trie::Node *tmp = curr->compressedSuffLink;//        while( tmp != trie.root.get() ) {//            for( const int32_t index : tmp->terminalForIndex ) {//                if( charNum > patternSize || charNum + 1 >= index + tmp->depth ) {//                    matches[(charNum + 1 - (index + tmp->depth)) % (2 * patternSize)] += 1;//                }//            }//            tmp = tmp->compressedSuffLink;//        }        ++charNum;        ++in;    }    if( charNum >= patternSize ){        if( matches[(charNum + patternSize) % (2 * patternSize)] == pieceNumber ) {            std::cout << charNum - patternSize;        }    }}int main() {    std::cin.tie(nullptr);    std::ios::sync_with_stdio(false);    std::string pattern;    std::cin >> pattern;    std::istream_iterator<char> istream( std::cin );    std::istream_iterator<char> eof;    Trie trie( split(pattern) );    printMatches(istream, eof, trie);    return 0;}